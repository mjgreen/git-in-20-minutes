[
  {
    "objectID": "index.html#github-is-like-osf",
    "href": "index.html#github-is-like-osf",
    "title": "git in 20 minutes",
    "section": "GitHub is like OSF",
    "text": "GitHub is like OSF\n\n\na website\n\nstore an article\nstore supplementary materials\nmake them available for download"
  },
  {
    "objectID": "index.html#github-is-like-onedrive",
    "href": "index.html#github-is-like-onedrive",
    "title": "git in 20 minutes",
    "section": "GitHub is like OneDrive",
    "text": "GitHub is like OneDrive\n\n\nshared files & collaborative authoring\none master version & time travel\nbut …\nQ. Who controls when OneDrive files sync?\n\nA. OneDrive controls sync\n\nQ. Who controls when GitHub files sync?\n\nA. You control sync"
  },
  {
    "objectID": "index.html#when-osf-might-be-better",
    "href": "index.html#when-osf-might-be-better",
    "title": "git in 20 minutes",
    "section": "when OSF might be better",
    "text": "when OSF might be better\n\nWhen your files are MS Office\n\nbecause git can’t see inside binaries\n\nWhen your collaborators don’t use git\n\nunless you want to teach them"
  },
  {
    "objectID": "index.html#git-as-aid-climbing",
    "href": "index.html#git-as-aid-climbing",
    "title": "git in 20 minutes",
    "section": "git as ‘aid’ climbing",
    "text": "git as ‘aid’ climbing\n\n\n\n\n\nIf this guy slips in a minute, he only falls back to the last bit of ‘protection’ - the spike he hammered in here a moment ago.\ngit has this concept too. When you reach a stable point, you do a “commit” action. If you make a mess after that, you can “reset” to get back to that stable point."
  },
  {
    "objectID": "index.html#a-look-at-a-github-repo",
    "href": "index.html#a-look-at-a-github-repo",
    "title": "git in 20 minutes",
    "section": "a look at a github repo",
    "text": "a look at a github repo\n\n?show the vagueness repo"
  },
  {
    "objectID": "index.html#horses-for-courses",
    "href": "index.html#horses-for-courses",
    "title": "git in 20 minutes",
    "section": "horses for courses",
    "text": "horses for courses\n\nChoose the right tool for the job\n\nGlasgow stats books: https://psyteachr.github.io/\n\nGithub Pages for students reading the books;\ngithub repo for staff collaborating on writing the books\nLisa’s github repo for developing the templates in R\nEmily’s OSF https://osf.io/bj83f/ for journal article on data viz\n\nr4ds: https://r4ds.had.co.nz/"
  },
  {
    "objectID": "index.html#github-use-case",
    "href": "index.html#github-use-case",
    "title": "git in 20 minutes",
    "section": "github use case",
    "text": "github use case\n\nPhD student learning an advanced analysis & plots\n\nrepo\nlogs\nstart with a script that does the thing\ninfer incrementally how the thing is done"
  },
  {
    "objectID": "index.html#commit-push-pull",
    "href": "index.html#commit-push-pull",
    "title": "git in 20 minutes",
    "section": "commit; push; pull",
    "text": "commit; push; pull\n\nWhen you commit, you make a stable point on your local computer …\n… but GitHub the website doesn’t know that yet.\ngit push is the action you do to send that stable point to the website.\nYour co-author does git pull to join you at that stable point, on their machine."
  },
  {
    "objectID": "index.html#clone-checkout",
    "href": "index.html#clone-checkout",
    "title": "git in 20 minutes",
    "section": "clone; checkout",
    "text": "clone; checkout\n\nIf you spill wine on your laptop and it dies, you can switch to another machine and say git clone - and you are back at the last stable point\nIf you decide that everything you’ve done since last month is garbage, you can git checkout a specific commit from the previous month and be back at that stable point."
  },
  {
    "objectID": "index.html#git-and-time-travel",
    "href": "index.html#git-and-time-travel",
    "title": "git in 20 minutes",
    "section": "git and time travel",
    "text": "git and time travel\n\ngit starts by storing the full contents of the files you commit first\nthen next time you commit, git figures out what you’d need to do to change that into what you’ve got now. Then it stores those differences (only the differences, not the new files themselves)."
  },
  {
    "objectID": "index.html#git-and-time-travel-1",
    "href": "index.html#git-and-time-travel-1",
    "title": "git in 20 minutes",
    "section": "git and time travel",
    "text": "git and time travel\n\nso a git repository consists of:\n\nthe full files from the first commit\nand a set of differences per subsequent commit.\n\nThis is very efficient, and means that everyone with a copy of the repository has the ability to re-construct any state from the past by applying the relevant set of differences to the original files. Hence, git lets you travel into the past and back again."
  },
  {
    "objectID": "index.html#git-and-open-science",
    "href": "index.html#git-and-open-science",
    "title": "git in 20 minutes",
    "section": "git and open science",
    "text": "git and open science"
  },
  {
    "objectID": "index.html#solving-the-multiple-concurrent-version-problem",
    "href": "index.html#solving-the-multiple-concurrent-version-problem",
    "title": "git in 20 minutes",
    "section": "solving the multiple concurrent version problem",
    "text": "solving the multiple concurrent version problem"
  },
  {
    "objectID": "index.html#live-demo-if-time-permits",
    "href": "index.html#live-demo-if-time-permits",
    "title": "git in 20 minutes",
    "section": "live demo if time permits",
    "text": "live demo if time permits\n\n\n\nhttps://mjgreen.github.io/git-in-20-minutes"
  }
]